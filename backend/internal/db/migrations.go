package db

import (
	"database/sql"
	"fmt"
	"strings"
)

const MigrationSQL = `
CREATE TABLE IF NOT EXISTS users (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    email TEXT NOT NULL UNIQUE,
    hashed_password TEXT NOT NULL,
    is_active INTEGER NOT NULL DEFAULT 1,
    is_superuser INTEGER NOT NULL DEFAULT 0,
    is_verified INTEGER NOT NULL DEFAULT 0,
    google_id TEXT UNIQUE,
    name TEXT,
    picture_url TEXT,
    political_leaning TEXT,
    state TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_login_at TIMESTAMPTZ
);

CREATE TABLE IF NOT EXISTS agencies (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    fr_agency_id BIGINT NOT NULL UNIQUE,
    raw_name TEXT NOT NULL,
    name TEXT NOT NULL,
    short_name TEXT,
    slug TEXT NOT NULL,
    description TEXT,
    url TEXT,
    json_url TEXT,
    parent_id BIGINT,
    raw_data TEXT NOT NULL DEFAULT '{}',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS federal_register_documents (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    source TEXT NOT NULL,
    source_id TEXT NOT NULL,
    unique_key TEXT NOT NULL UNIQUE,
    document_number TEXT NOT NULL,
    raw_data TEXT NOT NULL,
    fetched_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    title TEXT NOT NULL,
    agency TEXT,
    summary TEXT NOT NULL,
    keypoints JSONB,
    impact_score TEXT,
    political_score INTEGER,
    source_url TEXT NOT NULL,
    published_at TIMESTAMPTZ NOT NULL,
    document_type TEXT,
    pdf_url TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS feed_entries (
    id BIGSERIAL PRIMARY KEY,
    source_type TEXT NOT NULL,
    title TEXT NOT NULL,
    short_text TEXT NOT NULL,
    key_points JSONB,
    political_score INTEGER,
    impact_score TEXT,
    source_url TEXT NOT NULL,
    published_at TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS bookmarks (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    feed_entry_id BIGINT NOT NULL REFERENCES feed_entries(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(user_id, feed_entry_id)
);

CREATE TABLE IF NOT EXISTS likes (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    feed_entry_id BIGINT NOT NULL REFERENCES feed_entries(id) ON DELETE CASCADE,
    value INTEGER NOT NULL DEFAULT 1,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(user_id, feed_entry_id),
    CHECK (value IN (1, -1))
);

CREATE INDEX IF NOT EXISTS idx_federal_register_documents_published_at ON federal_register_documents(published_at);
CREATE INDEX IF NOT EXISTS idx_federal_register_documents_unique_key ON federal_register_documents(unique_key);
CREATE INDEX IF NOT EXISTS idx_feed_entries_published_at ON feed_entries(published_at DESC);
CREATE INDEX IF NOT EXISTS idx_feed_entries_source_type ON feed_entries(source_type);
CREATE INDEX IF NOT EXISTS idx_bookmarks_user_id ON bookmarks(user_id);
CREATE INDEX IF NOT EXISTS idx_bookmarks_feed_entry_id ON bookmarks(feed_entry_id);
CREATE INDEX IF NOT EXISTS idx_likes_user_id ON likes(user_id);
CREATE INDEX IF NOT EXISTS idx_likes_feed_entry_id ON likes(feed_entry_id);
CREATE INDEX IF NOT EXISTS idx_likes_feed_entry_id_value ON likes(feed_entry_id, value);
`

func (db *DB) RunMigrations() error {
	tx, err := db.Begin()
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	statements := splitStatements(MigrationSQL)
	for _, stmt := range statements {
		stmt = strings.TrimSpace(stmt)
		if stmt == "" {
			continue
		}
		if _, err := tx.Exec(stmt); err != nil {
			return fmt.Errorf("failed to run migration: %w", err)
		}
	}

	if err := db.addMissingColumns(tx); err != nil {
		return fmt.Errorf("failed to add missing columns: %w", err)
	}

	return tx.Commit()
}

func splitStatements(sql string) []string {
	var statements []string
	var current strings.Builder
	inSingleQuote := false
	inDoubleQuote := false
	inComment := false
	parens := 0

	for i := 0; i < len(sql); i++ {
		ch := sql[i]

		if inComment {
			if ch == '\n' {
				inComment = false
			}
			continue
		}

		if ch == '-' && i+1 < len(sql) && sql[i+1] == '-' {
			inComment = true
			i++
			continue
		}

		if ch == '\'' && !inDoubleQuote {
			inSingleQuote = !inSingleQuote
		}
		if ch == '"' && !inSingleQuote {
			inDoubleQuote = !inDoubleQuote
		}

		if !inSingleQuote && !inDoubleQuote {
			if ch == '(' {
				parens++
			}
			if ch == ')' {
				parens--
			}
		}

		if ch == ';' && parens == 0 && !inSingleQuote && !inDoubleQuote && !inComment {
			stmt := current.String()
			if strings.TrimSpace(stmt) != "" {
				statements = append(statements, stmt)
			}
			current.Reset()
		} else {
			current.WriteByte(ch)
		}
	}

	stmt := current.String()
	if strings.TrimSpace(stmt) != "" {
		statements = append(statements, stmt)
	}

	return statements
}

func (db *DB) addMissingColumns(tx *sql.Tx) error {
	var count int

	err := tx.QueryRow("SELECT COUNT(*) FROM information_schema.columns WHERE table_schema = 'public' AND table_name = 'federal_register_documents' AND column_name = 'source'").Scan(&count)
	if err != nil {
		return err
	}
	if count == 0 {
		_, err = tx.Exec("ALTER TABLE federal_register_documents ADD COLUMN source TEXT NOT NULL DEFAULT 'federal_register'")
		if err != nil && !strings.Contains(err.Error(), "already exists") {
			return err
		}

		_, err = tx.Exec("ALTER TABLE federal_register_documents ADD COLUMN source_id TEXT NOT NULL DEFAULT ''")
		if err != nil && !strings.Contains(err.Error(), "already exists") {
			return err
		}

		_, err = tx.Exec("ALTER TABLE federal_register_documents ADD COLUMN unique_key TEXT")
		if err != nil && !strings.Contains(err.Error(), "already exists") {
			return err
		}

		_, err = tx.Exec("UPDATE federal_register_documents SET source = 'federal_register', source_id = document_number, unique_key = 'federal_register:' || document_number WHERE source IS NULL OR source = ''")
		if err != nil {
			return fmt.Errorf("failed to backfill source columns: %w", err)
		}

		_, err = tx.Exec("CREATE UNIQUE INDEX IF NOT EXISTS idx_federal_register_documents_unique_key ON federal_register_documents(unique_key)")
		if err != nil && !strings.Contains(err.Error(), "already exists") {
			return fmt.Errorf("failed to create unique_key index: %w", err)
		}
	}

	err = tx.QueryRow("SELECT COUNT(*) FROM information_schema.columns WHERE table_schema = 'public' AND table_name = 'federal_register_documents' AND column_name = 'document_type'").Scan(&count)
	if err != nil {
		return err
	}
	if count == 0 {
		_, err = tx.Exec("ALTER TABLE federal_register_documents ADD COLUMN document_type TEXT")
		if err != nil && !strings.Contains(err.Error(), "already exists") {
			return err
		}
	}

	err = tx.QueryRow("SELECT COUNT(*) FROM information_schema.columns WHERE table_schema = 'public' AND table_name = 'federal_register_documents' AND column_name = 'pdf_url'").Scan(&count)
	if err != nil {
		return err
	}
	if count == 0 {
		_, err = tx.Exec("ALTER TABLE federal_register_documents ADD COLUMN pdf_url TEXT")
		if err != nil && !strings.Contains(err.Error(), "already exists") {
			return err
		}
	}

	err = tx.QueryRow("SELECT COUNT(*) FROM information_schema.columns WHERE table_schema = 'public' AND table_name = 'users' AND column_name = 'state'").Scan(&count)
	if err != nil {
		return err
	}
	if count == 0 {
		_, err = tx.Exec("ALTER TABLE users ADD COLUMN state TEXT")
		if err != nil && !strings.Contains(err.Error(), "already exists") {
			return err
		}
	}

	err = tx.QueryRow("SELECT COUNT(*) FROM information_schema.columns WHERE table_schema = 'public' AND table_name = 'agencies' AND column_name = 'raw_name'").Scan(&count)
	if err != nil {
		return err
	}
	if count == 0 {
		_, err = tx.Exec("ALTER TABLE agencies ADD COLUMN raw_name TEXT NOT NULL DEFAULT ''")
		if err != nil && !strings.Contains(err.Error(), "already exists") {
			return err
		}
	}

	// Add new AI-generated fields
	err = tx.QueryRow("SELECT COUNT(*) FROM information_schema.columns WHERE table_schema = 'public' AND table_name = 'federal_register_documents' AND column_name = 'agency'").Scan(&count)
	if err != nil {
		return err
	}
	if count == 0 {
		_, err = tx.Exec("ALTER TABLE federal_register_documents ADD COLUMN agency TEXT")
		if err != nil && !strings.Contains(err.Error(), "already exists") {
			return err
		}
	}
	_, err = tx.Exec("ALTER TABLE federal_register_documents DROP COLUMN IF EXISTS department")
	if err != nil && !strings.Contains(err.Error(), "does not exist") {
		return err
	}

	var keypointsType string
	err = tx.QueryRow("SELECT data_type FROM information_schema.columns WHERE table_schema = 'public' AND table_name = 'federal_register_documents' AND column_name = 'keypoints'").Scan(&keypointsType)
	if err != nil && err != sql.ErrNoRows {
		return err
	}
	if keypointsType == "" {
		_, err = tx.Exec("ALTER TABLE federal_register_documents ADD COLUMN keypoints JSONB")
		if err != nil && !strings.Contains(err.Error(), "already exists") {
			return err
		}
	} else if keypointsType != "jsonb" {
		_, err = tx.Exec("ALTER TABLE federal_register_documents ALTER COLUMN keypoints TYPE JSONB USING keypoints::jsonb")
		if err != nil && !strings.Contains(err.Error(), "already exists") {
			return err
		}
	}

	err = tx.QueryRow("SELECT COUNT(*) FROM information_schema.columns WHERE table_schema = 'public' AND table_name = 'federal_register_documents' AND column_name = 'impact_score'").Scan(&count)
	if err != nil {
		return err
	}
	if count == 0 {
		_, err = tx.Exec("ALTER TABLE federal_register_documents ADD COLUMN impact_score TEXT")
		if err != nil && !strings.Contains(err.Error(), "already exists") {
			return err
		}
	}

	err = tx.QueryRow("SELECT COUNT(*) FROM information_schema.columns WHERE table_schema = 'public' AND table_name = 'federal_register_documents' AND column_name = 'political_score'").Scan(&count)
	if err != nil {
		return err
	}
	if count == 0 {
		_, err = tx.Exec("ALTER TABLE federal_register_documents ADD COLUMN political_score INTEGER")
		if err != nil && !strings.Contains(err.Error(), "already exists") {
			return err
		}
	}

	err = tx.QueryRow("SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'feed_entries'").Scan(&count)
	if err != nil {
		return err
	}
	if count == 0 {
		_, err = tx.Exec(`
			CREATE TABLE feed_entries (
				id BIGSERIAL PRIMARY KEY,
				source_type TEXT NOT NULL,
				title TEXT NOT NULL,
				short_text TEXT NOT NULL,
				key_points JSONB,
				political_score INTEGER,
				impact_score TEXT,
				source_url TEXT NOT NULL,
				published_at TIMESTAMPTZ NOT NULL,
				created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
				updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
			)
		`)
		if err != nil {
			return fmt.Errorf("failed to create feed_entries table: %w", err)
		}

		_, err = tx.Exec("CREATE INDEX idx_feed_entries_published_at ON feed_entries(published_at DESC)")
		if err != nil {
			return fmt.Errorf("failed to create feed_entries index: %w", err)
		}

		_, err = tx.Exec("CREATE INDEX idx_feed_entries_source_type ON feed_entries(source_type)")
		if err != nil {
			return fmt.Errorf("failed to create source_type index: %w", err)
		}
	}

	err = tx.QueryRow("SELECT COUNT(*) FROM information_schema.columns WHERE table_schema = 'public' AND table_name = 'federal_register_documents' AND column_name = 'feed_entry_id'").Scan(&count)
	if err != nil {
		return err
	}
	if count == 0 {
		_, err = tx.Exec("ALTER TABLE federal_register_documents ADD COLUMN feed_entry_id BIGINT")
		if err != nil && !strings.Contains(err.Error(), "already exists") {
			return err
		}

		_, err = tx.Exec("ALTER TABLE federal_register_documents ADD CONSTRAINT federal_register_documents_feed_entry_id_fkey FOREIGN KEY (feed_entry_id) REFERENCES feed_entries(id) ON DELETE CASCADE")
		if err != nil && !strings.Contains(err.Error(), "already exists") {
			return fmt.Errorf("failed to add feed_entry_id foreign key: %w", err)
		}

		_, err = tx.Exec("ALTER TABLE federal_register_documents ADD UNIQUE (feed_entry_id)")
		if err != nil && !strings.Contains(err.Error(), "already exists") {
			return fmt.Errorf("failed to add feed_entry_id unique constraint: %w", err)
		}
	}

	err = tx.QueryRow("SELECT COUNT(*) FROM information_schema.columns WHERE table_schema = 'public' AND table_name = 'bookmarks' AND column_name = 'feed_entry_id'").Scan(&count)
	if err != nil {
		return err
	}
	if count == 0 {
		_, err = tx.Exec("ALTER TABLE bookmarks ADD COLUMN feed_entry_id BIGINT")
		if err != nil && !strings.Contains(err.Error(), "already exists") {
			return err
		}

		_, err = tx.Exec("ALTER TABLE bookmarks ADD CONSTRAINT bookmarks_feed_entry_id_fkey FOREIGN KEY (feed_entry_id) REFERENCES feed_entries(id) ON DELETE CASCADE")
		if err != nil && !strings.Contains(err.Error(), "already exists") {
			return fmt.Errorf("failed to add bookmarks feed_entry_id foreign key: %w", err)
		}

		_, err = tx.Exec("ALTER TABLE bookmarks DROP CONSTRAINT IF EXISTS bookmarks_pkey")
		if err != nil {
			return fmt.Errorf("failed to drop bookmarks primary key: %w", err)
		}

		_, err = tx.Exec("ALTER TABLE bookmarks ADD PRIMARY KEY (user_id, feed_entry_id)")
		if err != nil {
			return fmt.Errorf("failed to add bookmarks primary key: %w", err)
		}

		var indexCount int
		err = tx.QueryRow("SELECT COUNT(*) FROM pg_indexes WHERE indexname = 'idx_bookmarks_feed_entry_id'").Scan(&indexCount)
		if err != nil {
			return fmt.Errorf("failed to check idx_bookmarks_feed_entry_id index: %w", err)
		}
		if indexCount == 0 {
			_, err = tx.Exec("CREATE INDEX IF NOT EXISTS idx_bookmarks_feed_entry_id ON bookmarks(feed_entry_id)")
			if err != nil {
				return fmt.Errorf("failed to create bookmarks feed_entry_id index: %w", err)
			}
		}

		_, err = tx.Exec("ALTER TABLE bookmarks DROP COLUMN IF EXISTS frarticle_id")
		if err != nil && !strings.Contains(err.Error(), "does not exist") {
			return fmt.Errorf("failed to drop frarticle_id column: %w", err)
		}
	}

	err = tx.QueryRow("SELECT COUNT(*) FROM information_schema.columns WHERE table_schema = 'public' AND table_name = 'likes' AND column_name = 'feed_entry_id'").Scan(&count)
	if err != nil {
		return err
	}
	if count == 0 {
		_, err = tx.Exec("ALTER TABLE likes ADD COLUMN feed_entry_id BIGINT")
		if err != nil && !strings.Contains(err.Error(), "already exists") {
			return err
		}

		_, err = tx.Exec("ALTER TABLE likes ADD CONSTRAINT likes_feed_entry_id_fkey FOREIGN KEY (feed_entry_id) REFERENCES feed_entries(id) ON DELETE CASCADE")
		if err != nil && !strings.Contains(err.Error(), "already exists") {
			return fmt.Errorf("failed to add likes feed_entry_id foreign key: %w", err)
		}

		_, err = tx.Exec("ALTER TABLE likes DROP CONSTRAINT IF EXISTS likes_pkey")
		if err != nil {
			return fmt.Errorf("failed to drop likes primary key: %w", err)
		}

		_, err = tx.Exec("ALTER TABLE likes ADD PRIMARY KEY (user_id, feed_entry_id)")
		if err != nil {
			return fmt.Errorf("failed to add likes primary key: %w", err)
		}

		var indexCount int
		err = tx.QueryRow("SELECT COUNT(*) FROM pg_indexes WHERE indexname = 'idx_likes_feed_entry_id'").Scan(&indexCount)
		if err != nil {
			return fmt.Errorf("failed to check idx_likes_feed_entry_id index: %w", err)
		}
		if indexCount == 0 {
			_, err = tx.Exec("CREATE INDEX IF NOT EXISTS idx_likes_feed_entry_id ON likes(feed_entry_id)")
			if err != nil {
				return fmt.Errorf("failed to create likes feed_entry_id index: %w", err)
			}
		}

		_, err = tx.Exec("ALTER TABLE likes DROP COLUMN IF EXISTS frarticle_id")
		if err != nil && !strings.Contains(err.Error(), "does not exist") {
			return fmt.Errorf("failed to drop frarticle_id column: %w", err)
		}
	}

	// Bookmarks: existence-based (row presence = bookmarked)
	err = tx.QueryRow("SELECT COUNT(*) FROM information_schema.columns WHERE table_schema = 'public' AND table_name = 'bookmarks' AND column_name = 'is_bookmarked'").Scan(&count)
	if err != nil {
		return err
	}
	if count > 0 {
		_, err = tx.Exec("DELETE FROM bookmarks WHERE is_bookmarked = 0")
		if err != nil {
			return fmt.Errorf("failed to delete unbookmarked rows: %w", err)
		}
		_, err = tx.Exec("ALTER TABLE bookmarks DROP COLUMN IF EXISTS is_bookmarked")
		if err != nil && !strings.Contains(err.Error(), "does not exist") {
			return fmt.Errorf("failed to drop is_bookmarked column: %w", err)
		}
	}

	// Likes: use value (1 = like, -1 = dislike)
	err = tx.QueryRow("SELECT COUNT(*) FROM information_schema.columns WHERE table_schema = 'public' AND table_name = 'likes' AND column_name = 'value'").Scan(&count)
	if err != nil {
		return err
	}
	if count == 0 {
		_, err = tx.Exec("ALTER TABLE likes ADD COLUMN value INTEGER NOT NULL DEFAULT 1")
		if err != nil && !strings.Contains(err.Error(), "already exists") {
			return fmt.Errorf("failed to add likes.value column: %w", err)
		}
	}

	var hasIsLiked int
	err = tx.QueryRow("SELECT COUNT(*) FROM information_schema.columns WHERE table_schema = 'public' AND table_name = 'likes' AND column_name = 'is_liked'").Scan(&hasIsLiked)
	if err != nil {
		return err
	}
	if hasIsLiked > 0 {
		_, err = tx.Exec("UPDATE likes SET value = CASE WHEN is_liked = 1 THEN 1 ELSE -1 END")
		if err != nil {
			return fmt.Errorf("failed to backfill likes.value: %w", err)
		}
		_, err = tx.Exec("DROP INDEX IF EXISTS idx_likes_feed_entry_id_value")
		if err != nil {
			return fmt.Errorf("failed to drop old likes composite index: %w", err)
		}
		_, err = tx.Exec("ALTER TABLE likes DROP COLUMN IF EXISTS is_liked")
		if err != nil && !strings.Contains(err.Error(), "does not exist") {
			return fmt.Errorf("failed to drop is_liked column: %w", err)
		}
	}

	var constraintCount int
	err = tx.QueryRow("SELECT COUNT(*) FROM pg_constraint WHERE conname = 'likes_value_check'").Scan(&constraintCount)
	if err != nil {
		return fmt.Errorf("failed to check likes_value_check constraint: %w", err)
	}
	if constraintCount == 0 {
		_, err = tx.Exec("ALTER TABLE likes ADD CONSTRAINT likes_value_check CHECK (value IN (1, -1))")
		if err != nil {
			return fmt.Errorf("failed to add likes.value check constraint: %w", err)
		}
	}

	var indexCount int
	err = tx.QueryRow("SELECT COUNT(*) FROM pg_indexes WHERE indexname = 'idx_likes_feed_entry_id_value'").Scan(&indexCount)
	if err != nil {
		return fmt.Errorf("failed to check idx_likes_feed_entry_id_value index: %w", err)
	}
	if indexCount == 0 {
		_, err = tx.Exec("CREATE INDEX IF NOT EXISTS idx_likes_feed_entry_id_value ON likes(feed_entry_id, value)")
		if err != nil {
			return fmt.Errorf("failed to create likes composite index: %w", err)
		}
	}

	return nil
}
